<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Oct 12 19:39:18 CEST 1999 -->
<TITLE>
: Class  Tokenizer
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../grace/util/Timer.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Tokenizer.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
grace.util</FONT>
<BR>
Class  Tokenizer</H2>
<PRE>
java.lang.Object
  |
  +--<B>grace.util.Tokenizer</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Tokenizer</B><DT>extends java.lang.Object</DL>

<P>
Performs data scanning, gathering, and conversion functions on
 text.  This class provides functions to read various canned object
 like Strings, Dates, and integers as well as user defined object
 types.  Most of the functionality uses regular expressions to
 locate and delimit the text.

 <p>Objects of this class are stateful in that they maintain a
 current position.  As data is parsed, this current position is
 moved forwards or backwards.  Operations that get data from the
 source typically set the current position in the source at the end
 of the data returned.

 <p>Synopsis:
 <pre>
   Tokenizer tokenizer = new Tokenizer("some text\nmore text\nnumCards=52");
   int numCards = tokenizer.getPrefixedInt("numCards=(\d+)", "$1");
 </pre>

 <p>Notes:

 <p>If this class is used for scraping screens, the screen text
 should contain any newlines that a meaningful to the format.  This
 makes the * the screen scraping code more maintainable. In other
 words, newlines should not be stripped out.  This will keep the
 parsing code independent from the length of the lines in the text.
 Therefore, if the text contains newlines and if the line length is
 changed someday, the parsing code should not need to be changed.
<P>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#Tokenizer(java.lang.String)">Tokenizer</A></B>(java.lang.String&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#advance(int)">advance</A></B>(int&nbsp;numCharacters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the current position forward the given number of
 characters.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#advance(gnu.regexp.RE)">advance</A></B>(gnu.regexp.RE&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advances the current position in the source to the start of the
 match of given expression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#advance(gnu.regexp.RE, int)">advance</A></B>(gnu.regexp.RE&nbsp;expression,
        int&nbsp;positionAtSubExpressionNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advances the current position in the source to the start of the
 match of given numbered subexpression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#advance(java.lang.String)">advance</A></B>(java.lang.String&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advances the current position in the source to the start of the
 match given expression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#advance(java.lang.String, int)">advance</A></B>(java.lang.String&nbsp;expression,
        int&nbsp;positionAtSubExpressionNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advances the current position in the source to the start of the
 match of given numbered subexpression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The copy allows the caller to capture the current state of this
 Tokenizer such that this Tokenizer can continue parsing but not
 affect the copy.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#find(gnu.regexp.RE)">find</A></B>(gnu.regexp.RE&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first string in the input that matches the given
 regular expression or null if there are none.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#find(java.lang.String)">find</A></B>(java.lang.String&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first string in the input that matches the given
 regular expression or null if there are none.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#findAndSubstitute(gnu.regexp.RE, java.lang.String)">findAndSubstitute</A></B>(gnu.regexp.RE&nbsp;regularExpression,
                  java.lang.String&nbsp;substituteString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the result of substituting the result of the first
 match of the given regularExpression into the given
 substituteString.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#findAndSubstitute(java.lang.String, java.lang.String)">findAndSubstitute</A></B>(java.lang.String&nbsp;regularExpression,
                  java.lang.String&nbsp;substituteString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the result of substituting the result of the first
 match of the given regularExpression into the given
 substituteString.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#get(gnu.regexp.RE)">get</A></B>(gnu.regexp.RE&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the text that matches the given regularExpression that
 is assumed to start at the current position in the input source
 or returns null if at the end of the source.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#get(gnu.regexp.RE, int)">get</A></B>(gnu.regexp.RE&nbsp;expression,
    int&nbsp;maxOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the next match not more than <code>maxOffset</code>
 characters from the current position in the input stream or
 null if there are no more tokens.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#get(java.lang.String)">get</A></B>(java.lang.String&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the text that matches the given regularExpression that
 is assumed to start at the current position in the input source
 or returns null if at the end of the source.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#get(java.lang.String, int)">get</A></B>(java.lang.String&nbsp;regularExpression,
    int&nbsp;maxOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the next match not more than <code>maxOffset</code>
 characters from the current position in the input stream or
 null if there are no more tokens.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getDate(java.text.DateFormat)">getDate</A></B>(java.text.DateFormat&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token as a Date parsed by the given
 format.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getDate(java.lang.String)">getDate</A></B>(java.lang.String&nbsp;simpleDateFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token as a Date parsed by a
 SimpleDateFormat object created with the given simpleDateFormat
 string.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getInt()">getInt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token (skipping white space) as an
 integer.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getInt(int)">getInt</A></B>(int&nbsp;maxNumDigits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token (skipping white space) as an
 integer of the given maximum number of digits.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getInt(gnu.regexp.RE, java.lang.String)">getInt</A></B>(gnu.regexp.RE&nbsp;expression,
       java.lang.String&nbsp;substitution)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This matches the given regular expression, sustitutes the match
 into the given substitution string, parses the result as an
 integer, and returns the result as an integer.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getInt(java.lang.String, java.lang.String)">getInt</A></B>(java.lang.String&nbsp;expression,
       java.lang.String&nbsp;substitution)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This takes matches the given regular expression, sustitutes the
 match into the given substitution string, parses the result as
 an integer, and returns the result.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getLine()">getLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a line of text (delimited by newline) from input
 without the newline character in the result.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getMatch(gnu.regexp.RE)">getMatch</A></B>(gnu.regexp.RE&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility function that returns the first match in the source of
 the given regular expression and sets the current position to
 the end of the first match.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getNextInt()">getNextInt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next integer in the input (skipping non
 decimal digits and white space).</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPosition()">getPosition</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the index of current position in the source.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPrefixedDate(gnu.regexp.RE, java.text.DateFormat)">getPrefixedDate</A></B>(gnu.regexp.RE&nbsp;regularExpression,
                java.text.DateFormat&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by the format object.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPrefixedDate(gnu.regexp.RE, java.lang.String)">getPrefixedDate</A></B>(gnu.regexp.RE&nbsp;regularExpression,
                java.lang.String&nbsp;simpleDateFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by a SimpleDateFormat
 object created with the given simpleDateFormat string.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPrefixedDate(java.lang.String, java.text.DateFormat)">getPrefixedDate</A></B>(java.lang.String&nbsp;regularExpression,
                java.text.DateFormat&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by the format object.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPrefixedDate(java.lang.String, java.lang.String)">getPrefixedDate</A></B>(java.lang.String&nbsp;regularExpression,
                java.lang.String&nbsp;simpleDateFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by a SimpleDateFormat
 object created with the given simpleDateFormat string.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getPrefixedInt(java.lang.String)">getPrefixedInt</A></B>(java.lang.String&nbsp;tagRegularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the integer token <i>after</i> the matching
 regular expression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getSource()">getSource</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the entire source.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getSubstitutedMatch(gnu.regexp.RE, java.lang.String)">getSubstitutedMatch</A></B>(gnu.regexp.RE&nbsp;expression,
                    java.lang.String&nbsp;substitutionString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility function to find the first match of the given
 expression in the source, substitute the found match into the
 given susbstitution string and return the result.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getTime(java.text.DateFormat, java.util.Date)">getTime</A></B>(java.text.DateFormat&nbsp;timeFormat,
        java.util.Date&nbsp;date)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token as a Date parsed by the given
 time format but using the year, month, and date of the given
 date.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getTime(java.lang.String, java.util.Date)">getTime</A></B>(java.lang.String&nbsp;timeFormat,
        java.util.Date&nbsp;date)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses and returns the next token as a Date parsed by the given
 time format but using the year, month, and date of the given
 date.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getToken()">getToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the next white space delimited token in the input
 stream or null if there are no more tokens.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#getToken(int)">getToken</A></B>(int&nbsp;maxNumWhiteSpaceChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the next white space delimited token not more than
 <code>lastRelativeStartPosition</code> characters from the
 current position in the input stream or null if there are no
 more tokens.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#injectNewlines(int)">injectNewlines</A></B>(int&nbsp;lineLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Useful if the source text should contain but doesn't.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#isAt(gnu.regexp.RE)">isAt</A></B>(gnu.regexp.RE&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that the given regular expression will match the at
 current position.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#isAt(java.lang.String)">isAt</A></B>(java.lang.String&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that the given regular expression will match the at
 current position.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test program not quite completed.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#printTo(grace.io.PrintWriter)">printTo</A></B>(<A HREF="../../grace/io/PrintWriter.html">PrintWriter</A>&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used by grace.io.PrintWriter to nicely print this.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#retreat(int)">retreat</A></B>(int&nbsp;numCharacters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the current position backward the given number of
 characters.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#retreat(gnu.regexp.RE)">retreat</A></B>(gnu.regexp.RE&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retreats the current position in the source to the start of the
 given expression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#retreat(java.lang.String)">retreat</A></B>(java.lang.String&nbsp;regularExpression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retreats the current position in the source to the start of the
 given expression.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#setPosition(int)">setPosition</A></B>(int&nbsp;absolute)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the index of current position in the source.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#skipWhiteSpace()">skipWhiteSpace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the current position to the next character in the source
 that is not white as determined by
 java.lang.Character.isWhitespace().</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#toPrintable(java.lang.String)">toPrintable</A></B>(java.lang.String&nbsp;notPrintable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility function to convert strings that have embedded non
 printable characters such as newlines and tabs, and returns a
 string that may be cleanly printed.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../grace/util/Tokenizer.html#undoLast()">undoLast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This moves the current position to the position before the
 previous function was called.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE>equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Tokenizer(java.lang.String)"><!-- --></A><H3>
Tokenizer</H3>
<PRE>
public <B>Tokenizer</B>(java.lang.String&nbsp;source)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="injectNewlines(int)"><!-- --></A><H3>
injectNewlines</H3>
<PRE>
public void <B>injectNewlines</B>(int&nbsp;lineLength)</PRE>
<DL>
<DD>Useful if the source text should contain but doesn't.  This
 probably means that, at one time, the source text had newlines,
 but the newlines have been stripped out.  By injecting
 newlines, the source text is more maintainably parsed because
 the newlines add contextual information that was obviously
 meant for human visualization of the data.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lineLength</CODE> - periodic position in source at which newlines
 should be injected</DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public java.lang.Object <B>clone</B>()</PRE>
<DL>
<DD>The copy allows the caller to capture the current state of this
 Tokenizer such that this Tokenizer can continue parsing but not
 affect the copy.  For example, this is useful to capture
 <i>anchors</i> in input or perform different or parallel
 parsing operations.<DD><DL>
<DT><B>Overrides:</B><DD>clone in class java.lang.Object</DL>
</DD>
</DL>
<HR>

<A NAME="skipWhiteSpace()"><!-- --></A><H3>
skipWhiteSpace</H3>
<PRE>
public void <B>skipWhiteSpace</B>()</PRE>
<DL>
<DD>Moves the current position to the next character in the source
 that is not white as determined by
 java.lang.Character.isWhitespace().</DL>
<HR>

<A NAME="getMatch(gnu.regexp.RE)"><!-- --></A><H3>
getMatch</H3>
<PRE>
protected java.lang.String <B>getMatch</B>(gnu.regexp.RE&nbsp;expression)</PRE>
<DL>
<DD>Utility function that returns the first match in the source of
 the given regular expression and sets the current position to
 the end of the first match.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match, return, and position after<DT><B>Returns:</B><DD>first string matching expression in source</DL>
</DD>
</DL>
<HR>

<A NAME="getSubstitutedMatch(gnu.regexp.RE, java.lang.String)"><!-- --></A><H3>
getSubstitutedMatch</H3>
<PRE>
protected java.lang.String <B>getSubstitutedMatch</B>(gnu.regexp.RE&nbsp;expression,
                                               java.lang.String&nbsp;substitutionString)</PRE>
<DL>
<DD>Utility function to find the first match of the given
 expression in the source, substitute the found match into the
 given susbstitution string and return the result.  The
 substitution string may contain plain text as well as the
 symbols $0-$9 as dictated by the GNU regular expression
 library.  $0 refers the entire match and $1 through $9 refer to
 the first through the nineth matched sub expression.

 <p>The current position is positioned after the last matched
 character - not the end of the matched sub expression in the
 substitution, if any exists.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match<DD><CODE>substitutionString</CODE> - into which the matched expression in
 source is substituted.<DT><B>Returns:</B><DD>result of substituting the matched string found in
 source into the given substitutionString.</DL>
</DD>
</DL>
<HR>

<A NAME="advance(int)"><!-- --></A><H3>
advance</H3>
<PRE>
public void <B>advance</B>(int&nbsp;numCharacters)</PRE>
<DL>
<DD>Move the current position forward the given number of
 characters.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numCharacters</CODE> - to advance in the source</DL>
</DD>
</DL>
<HR>

<A NAME="advance(java.lang.String)"><!-- --></A><H3>
advance</H3>
<PRE>
public void <B>advance</B>(java.lang.String&nbsp;regularExpression)
             throws gnu.regexp.REException</PRE>
<DL>
<DD>Advances the current position in the source to the start of the
 match given expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to position at start of match<DT><B>Throws:</B><DD>gnu.regexp.REException - if the given regularExpression is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="advance(gnu.regexp.RE)"><!-- --></A><H3>
advance</H3>
<PRE>
public void <B>advance</B>(gnu.regexp.RE&nbsp;expression)</PRE>
<DL>
<DD>Advances the current position in the source to the start of the
 match of given expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to position at start of match</DL>
</DD>
</DL>
<HR>

<A NAME="advance(java.lang.String, int)"><!-- --></A><H3>
advance</H3>
<PRE>
public void <B>advance</B>(java.lang.String&nbsp;expression,
                    int&nbsp;positionAtSubExpressionNumber)
             throws gnu.regexp.REException</PRE>
<DL>
<DD>Advances the current position in the source to the start of the
 match of given numbered subexpression.  If the given expression
 contains no subexpressions, the current position is placed at
 the start of the matched expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match and position at sub expression<DD><CODE>positionAtSubExpressionNumber</CODE> - number of sub expression
 in expression to place current position.</DL>
</DD>
</DL>
<HR>

<A NAME="advance(gnu.regexp.RE, int)"><!-- --></A><H3>
advance</H3>
<PRE>
public void <B>advance</B>(gnu.regexp.RE&nbsp;expression,
                    int&nbsp;positionAtSubExpressionNumber)</PRE>
<DL>
<DD>Advances the current position in the source to the start of the
 match of given numbered subexpression.  If the given expression
 contains no subexpressions, the current position is placed at
 the start of the matched expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match and position at sub expression<DD><CODE>positionAtSubExpressionNumber</CODE> - number of sub expression
 in expression to place current position.</DL>
</DD>
</DL>
<HR>

<A NAME="find(java.lang.String)"><!-- --></A><H3>
find</H3>
<PRE>
public java.lang.String <B>find</B>(java.lang.String&nbsp;regularExpression)
                      throws gnu.regexp.REException</PRE>
<DL>
<DD>Returns the first string in the input that matches the given
 regular expression or null if there are none.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - &nbsp;<DT><B>Returns:</B><DD>first string in input that matches the
 regularExpression or null if there are no more tokens.<DT><B>Throws:</B><DD>gnu.regexp.REException - if regularExpression has syntax errors</DL>
</DD>
</DL>
<HR>

<A NAME="find(gnu.regexp.RE)"><!-- --></A><H3>
find</H3>
<PRE>
public java.lang.String <B>find</B>(gnu.regexp.RE&nbsp;regularExpression)</PRE>
<DL>
<DD>Returns the first string in the input that matches the given
 regular expression or null if there are none.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - &nbsp;<DT><B>Returns:</B><DD>first string in input that matches the
 regularExpression or null if there are no more tokens.</DL>
</DD>
</DL>
<HR>

<A NAME="findAndSubstitute(java.lang.String, java.lang.String)"><!-- --></A><H3>
findAndSubstitute</H3>
<PRE>
public java.lang.String <B>findAndSubstitute</B>(java.lang.String&nbsp;regularExpression,
                                          java.lang.String&nbsp;substituteString)
                                   throws gnu.regexp.REException</PRE>
<DL>
<DD>Returns the result of substituting the result of the first
 match of the given regularExpression into the given
 substituteString.  Returns null if no match is made.  The
 current position is set to next character after the end of
 found string in source.

 <p>This function uses the gnu.regexp.REMatch.substituteInto()
 function.  Therefore, the substitute string can contain plain
 text or the special symbols $0-$9.  $0 represents the entire
 matched string and $1-$9 represent the first thru the nineth
 matched sub expression respectively.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match one time<DD><CODE>substituteString</CODE> - into which match is substituted<DT><B>Returns:</B><DD>result of substitution of first match in input into the
 substituteString or null if no match is made.<DT><B>Throws:</B><DD>gnu.regexp.REException - if regularExpression has syntax errors<DT><B>See Also: </B><DD><CODE>gnu.regexp.RE.getMatch(Object)</CODE>, 
<CODE>gnu.regexp.REMatch.substituteInto(String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="findAndSubstitute(gnu.regexp.RE, java.lang.String)"><!-- --></A><H3>
findAndSubstitute</H3>
<PRE>
public java.lang.String <B>findAndSubstitute</B>(gnu.regexp.RE&nbsp;regularExpression,
                                          java.lang.String&nbsp;substituteString)</PRE>
<DL>
<DD>Returns the result of substituting the result of the first
 match of the given regularExpression into the given
 substituteString.  Returns null if no match is made.  The
 current position is set to next character after the end of
 found string in source.

 <p>This function uses the gnu.regexp.REMatch.substituteInto()
 function.  Therefore, the substitute string can contain plain
 text or the special symbols $0-$9.  $0 represents the entire
 matched string and $1-$9 represent the first thru the nineth
 matched sub expression respectively.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match one time<DD><CODE>substituteString</CODE> - into which match is substituted<DT><B>Returns:</B><DD>result of substitution of first match in input into the
 substituteString or returns null if no match is made.<DT><B>See Also: </B><DD><CODE>gnu.regexp.RE.getMatch(Object)</CODE>, 
<CODE>gnu.regexp.REMatch.substituteInto(String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="retreat(int)"><!-- --></A><H3>
retreat</H3>
<PRE>
public void <B>retreat</B>(int&nbsp;numCharacters)</PRE>
<DL>
<DD>Move the current position backward the given number of
 characters.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numCharacters</CODE> - to advance in the source</DL>
</DD>
</DL>
<HR>

<A NAME="retreat(java.lang.String)"><!-- --></A><H3>
retreat</H3>
<PRE>
public void <B>retreat</B>(java.lang.String&nbsp;regularExpression)
             throws gnu.regexp.REException</PRE>
<DL>
<DD>Retreats the current position in the source to the start of the
 given expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to position at start of match<DT><B>Throws:</B><DD>gnu.regexp.REException - if the given regularExpression is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="retreat(gnu.regexp.RE)"><!-- --></A><H3>
retreat</H3>
<PRE>
public void <B>retreat</B>(gnu.regexp.RE&nbsp;expression)</PRE>
<DL>
<DD>Retreats the current position in the source to the start of the
 given expression.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to position at start of match</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.String <B>get</B>(java.lang.String&nbsp;regularExpression)
                     throws gnu.regexp.REException</PRE>
<DL>
<DD>Returns the text that matches the given regularExpression that
 is assumed to start at the current position in the input source
 or returns null if at the end of the source.  The current
 position is set to next character after the end of found string
 in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match starting at current position<DT><B>Returns:</B><DD>immediate match of regularExpression or null if end of source</DL>
</DD>
</DL>
<HR>

<A NAME="get(gnu.regexp.RE)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.String <B>get</B>(gnu.regexp.RE&nbsp;expression)</PRE>
<DL>
<DD>Returns the text that matches the given regularExpression that
 is assumed to start at the current position in the input source
 or returns null if at the end of the source.  The current
 position is set to next character after the end of found string
 in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match starting at current position<DT><B>Returns:</B><DD>immediate match of regularExpression or null if end of source</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, int)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.String <B>get</B>(java.lang.String&nbsp;regularExpression,
                            int&nbsp;maxOffset)
                     throws gnu.regexp.REException</PRE>
<DL>
<DD>Returns the next match not more than <code>maxOffset</code>
 characters from the current position in the input stream or
 null if there are no more tokens.  This function is good for
 finding optional tokens that optionally appear in the source at
 or near a fixed position.  The current position is set to next
 character after the end of found string in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match starting at current position<DD><CODE>maxOffset</CODE> - maximum number of characters from current
 position that match will succeed<DT><B>Returns:</B><DD>matched string or null</DL>
</DD>
</DL>
<HR>

<A NAME="get(gnu.regexp.RE, int)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.String <B>get</B>(gnu.regexp.RE&nbsp;expression,
                            int&nbsp;maxOffset)</PRE>
<DL>
<DD>Returns the next match not more than <code>maxOffset</code>
 characters from the current position in the input stream or
 null if there are no more tokens.  This function is good for
 finding optional tokens that optionally appear in the source at
 or near a fixed position.  The current position is set to next
 character after the end of found string in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match starting at current position<DD><CODE>maxOffset</CODE> - maximum number of characters from current
 position that match will succeed<DT><B>Returns:</B><DD>matched string or null</DL>
</DD>
</DL>
<HR>

<A NAME="getToken()"><!-- --></A><H3>
getToken</H3>
<PRE>
public java.lang.String <B>getToken</B>()</PRE>
<DL>
<DD>Returns the next white space delimited token in the input
 stream or null if there are no more tokens.  Here, white space
 is a space, tab, or newline.  The current position is set to
 next character after the end of token in source.<DD><DL>
<DT><B>Returns:</B><DD>next white space delimited token string or null if end
 of source</DL>
</DD>
</DL>
<HR>

<A NAME="getToken(int)"><!-- --></A><H3>
getToken</H3>
<PRE>
public java.lang.String <B>getToken</B>(int&nbsp;maxNumWhiteSpaceChars)</PRE>
<DL>
<DD>Returns the next white space delimited token not more than
 <code>lastRelativeStartPosition</code> characters from the
 current position in the input stream or null if there are no
 more tokens.  This function is good for finding tokens that
 optionally appear in the source at or near a fixed position.
 The current position is set to next character after the end of
 token in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxNumWhiteSpaceChars</CODE> - &nbsp;<DT><B>Returns:</B><DD>next token or null if there are no more</DL>
</DD>
</DL>
<HR>

<A NAME="getLine()"><!-- --></A><H3>
getLine</H3>
<PRE>
public java.lang.String <B>getLine</B>()</PRE>
<DL>
<DD>Returns a line of text (delimited by newline) from input
 without the newline character in the result.  If the current
 position is on a newline, the next full line is returned.
 Otherwise, if the current position is in the middle of a line,
 the remainder of the line is returned.  If there are no lines
 left, null is returned.  The current position is set to start
 of the next line in the source.<DD><DL>
<DT><B>Returns:</B><DD>next line of text without the newline character or null
 if none</DL>
</DD>
</DL>
<HR>

<A NAME="getInt()"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>()
           throws java.lang.NumberFormatException</PRE>
<DL>
<DD>Parses and returns the next token (skipping white space) as an
 integer.  The current position is set to next character after
 the end of int token in source.<DD><DL>
<DT><B>Returns:</B><DD>result of parsing the next token as an int<DT><B>Throws:</B><DD>java.lang.NumberFormatException - if the next token is not an integer</DL>
</DD>
</DL>
<HR>

<A NAME="getInt(int)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(int&nbsp;maxNumDigits)
           throws java.lang.NumberFormatException</PRE>
<DL>
<DD>Parses and returns the next token (skipping white space) as an
 integer of the given maximum number of digits.  The current
 position is set to next character after the end of int token in
 source.<DD><DL>
<DT><B>Returns:</B><DD>result of parsing maxNumDigits of characters of the
 next token as an int<DT><B>Throws:</B><DD>java.lang.NumberFormatException - if the next token is not an integer</DL>
</DD>
</DL>
<HR>

<A NAME="getInt(java.lang.String, java.lang.String)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(java.lang.String&nbsp;expression,
                  java.lang.String&nbsp;substitution)
           throws java.lang.NumberFormatException,
                  gnu.regexp.REException</PRE>
<DL>
<DD>This takes matches the given regular expression, sustitutes the
 match into the given substitution string, parses the result as
 an integer, and returns the result.  The current position is
 set to next character after the end of int token in source.

 <p>This function uses the gnu.regexp.REMatch.substituteInto()
 function.  Therefore, the substitute string can contain plain
 text or the special symbols $0-$9.  $0 represents the entire
 matched string and $1-$9 represent the first thru the nineth
 matched sub expression respectively.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match in source<DD><CODE>substitution</CODE> - into which matched expression is substituted<DT><B>Returns:</B><DD>parsed integer result of subtituted match of given expression<DT><B>Throws:</B><DD>java.lang.NumberFormatException - if the sustituted value is not an int</DL>
</DD>
</DL>
<HR>

<A NAME="getInt(gnu.regexp.RE, java.lang.String)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(gnu.regexp.RE&nbsp;expression,
                  java.lang.String&nbsp;substitution)
           throws java.lang.NumberFormatException</PRE>
<DL>
<DD>This matches the given regular expression, sustitutes the match
 into the given substitution string, parses the result as an
 integer, and returns the result as an integer.

 <p>This function uses the gnu.regexp.REMatch.substituteInto()
 function.  Therefore, the substitute string can contain plain
 text or the special symbols $0-$9.  $0 represents the entire
 matched string and $1-$9 represent the first thru the nineth
 matched sub expression respectively.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match in source<DD><CODE>substitution</CODE> - into which matched expression is substituted<DT><B>Returns:</B><DD>parsed integer result of subtituted match of given expression<DT><B>Throws:</B><DD>java.lang.NumberFormatException - if the sustituted value is not an int</DL>
</DD>
</DL>
<HR>

<A NAME="getPrefixedInt(java.lang.String)"><!-- --></A><H3>
getPrefixedInt</H3>
<PRE>
public int <B>getPrefixedInt</B>(java.lang.String&nbsp;tagRegularExpression)
                   throws java.lang.NumberFormatException,
                          gnu.regexp.REException</PRE>
<DL>
<DD>Parses and returns the integer token <i>after</i> the matching
 regular expression.  This is useful if the integer is prefixed
 by some recogniseable string.  If an error occurs, the current
 position is not changed.  The current position is set to next
 character after the end of parsed int in source.<DD><DL>
<DT><B>Returns:</B><DD>parsed integer prefixed by given tagRegularExpression<DT><B>Throws:</B><DD>java.lang.NumberFormatException - if the next token is not an integer</DL>
</DD>
</DL>
<HR>

<A NAME="getNextInt()"><!-- --></A><H3>
getNextInt</H3>
<PRE>
public int <B>getNextInt</B>()
               throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the next integer in the input (skipping non
 decimal digits and white space).  The current position is set
 to next character after the end of next int token in source.<DD><DL>
<DT><B>Returns:</B><DD>next integer int source<DT><B>Throws:</B><DD>java.text.ParseException - if no integer in rest of input</DL>
</DD>
</DL>
<HR>

<A NAME="getDate(java.lang.String)"><!-- --></A><H3>
getDate</H3>
<PRE>
public java.util.Date <B>getDate</B>(java.lang.String&nbsp;simpleDateFormat)
                       throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the next token as a Date parsed by a
 SimpleDateFormat object created with the given simpleDateFormat
 string.  The current position is set to next character after
 the end of date in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>simpleDateFormat</CODE> - to create a SimpleDateFormat to parse the date<DT><B>Returns:</B><DD>next token parsed as a data according to given simpleDateFormat<DT><B>Throws:</B><DD>java.text.ParseException - if date failed to parse</DL>
</DD>
</DL>
<HR>

<A NAME="getDate(java.text.DateFormat)"><!-- --></A><H3>
getDate</H3>
<PRE>
public java.util.Date <B>getDate</B>(java.text.DateFormat&nbsp;format)
                       throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the next token as a Date parsed by the given
 format.  The current position is set to next character after
 the end of date in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>format</CODE> - to parse the date<DT><B>Returns:</B><DD>parsed Date from current position in source<DT><B>Throws:</B><DD>java.text.ParseException - if date failed to parse</DL>
</DD>
</DL>
<HR>

<A NAME="getTime(java.lang.String, java.util.Date)"><!-- --></A><H3>
getTime</H3>
<PRE>
public java.util.Date <B>getTime</B>(java.lang.String&nbsp;timeFormat,
                              java.util.Date&nbsp;date)
                       throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the next token as a Date parsed by the given
 time format but using the year, month, and date of the given
 date.  Notice that because the date portion of the parsed time
 is overwritten by the given date, only hours, minutes, and
 seconds parsing sequences are useful in the given timeFormat.
 The current position is set to next character after the end of
 time in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>format</CODE> - to parse the date<DD><CODE>date</CODE> - to fill into result<DT><B>Returns:</B><DD>parsed Date from current position in source<DT><B>Throws:</B><DD>java.text.ParseException - if date failed to parse</DL>
</DD>
</DL>
<HR>

<A NAME="getTime(java.text.DateFormat, java.util.Date)"><!-- --></A><H3>
getTime</H3>
<PRE>
public java.util.Date <B>getTime</B>(java.text.DateFormat&nbsp;timeFormat,
                              java.util.Date&nbsp;date)
                       throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the next token as a Date parsed by the given
 time format but using the year, month, and date of the given
 date.  Notice that because the date portion of the parsed time
 is overwritten by the given date, only hours, minutes, and
 seconds parsing sequences are useful in the given timeFormat.
 The current position is set to next character after the end of
 time in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>format</CODE> - to parse the date<DD><CODE>date</CODE> - to fill into result<DT><B>Returns:</B><DD>parsed Date from current position in source<DT><B>Throws:</B><DD>java.text.ParseException - if date failed to parse</DL>
</DD>
</DL>
<HR>

<A NAME="getPrefixedDate(java.lang.String, java.lang.String)"><!-- --></A><H3>
getPrefixedDate</H3>
<PRE>
public java.util.Date <B>getPrefixedDate</B>(java.lang.String&nbsp;regularExpression,
                                      java.lang.String&nbsp;simpleDateFormat)
                               throws java.text.ParseException,
                                      gnu.regexp.REException</PRE>
<DL>
<DD>Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by a SimpleDateFormat
 object created with the given simpleDateFormat string.  An
 object representing the regular expression may or may not be
 created.  The current position is set to next character after
 the end of Date in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match before parsing the date<DD><CODE>simpleDateFormat</CODE> - to use to parse the date<DT><B>Throws:</B><DD>java.text.ParseException - from SimpleDateFormat.parse()</DL>
</DD>
</DL>
<HR>

<A NAME="getPrefixedDate(gnu.regexp.RE, java.lang.String)"><!-- --></A><H3>
getPrefixedDate</H3>
<PRE>
public java.util.Date <B>getPrefixedDate</B>(gnu.regexp.RE&nbsp;regularExpression,
                                      java.lang.String&nbsp;simpleDateFormat)
                               throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by a SimpleDateFormat
 object created with the given simpleDateFormat string.  The
 current position is set to next character after the end of Date
 in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match before parsing the date<DD><CODE>simpleDateFormat</CODE> - to use to parse the date<DT><B>Throws:</B><DD>java.text.ParseException - from SimpleDateFormat.parse()</DL>
</DD>
</DL>
<HR>

<A NAME="getPrefixedDate(java.lang.String, java.text.DateFormat)"><!-- --></A><H3>
getPrefixedDate</H3>
<PRE>
public java.util.Date <B>getPrefixedDate</B>(java.lang.String&nbsp;regularExpression,
                                      java.text.DateFormat&nbsp;format)
                               throws java.text.ParseException,
                                      gnu.regexp.REException</PRE>
<DL>
<DD>Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by the format object.  An
 object representing the regular expression may or may not be
 created.  The current position is set to next character after
 the end of Date in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match before parsing the date<DD><CODE>format</CODE> - to use to parse the date<DT><B>Throws:</B><DD>java.text.ParseException - from SimpleDateFormat.parse()</DL>
</DD>
</DL>
<HR>

<A NAME="getPrefixedDate(gnu.regexp.RE, java.text.DateFormat)"><!-- --></A><H3>
getPrefixedDate</H3>
<PRE>
public java.util.Date <B>getPrefixedDate</B>(gnu.regexp.RE&nbsp;regularExpression,
                                      java.text.DateFormat&nbsp;format)
                               throws java.text.ParseException</PRE>
<DL>
<DD>Parses and returns the token, <i>after</i> the given regular
 expression matches, as a Date parsed by the format object.  The
 current position is set to next character after the end of Date
 in source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match before parsing the date<DD><CODE>format</CODE> - to use to parse the date<DT><B>Throws:</B><DD>java.text.ParseException - from SimpleDateFormat.parse()</DL>
</DD>
</DL>
<HR>

<A NAME="getPosition()"><!-- --></A><H3>
getPosition</H3>
<PRE>
public int <B>getPosition</B>()</PRE>
<DL>
<DD>Return the index of current position in the source.<DD><DL>
<DT><B>Returns:</B><DD>index of current position in source</DL>
</DD>
</DL>
<HR>

<A NAME="setPosition(int)"><!-- --></A><H3>
setPosition</H3>
<PRE>
public void <B>setPosition</B>(int&nbsp;absolute)</PRE>
<DL>
<DD>Set the index of current position in the source.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>absolute</CODE> - index to set<DT><B>Returns:</B><DD>index of current position in source</DL>
</DD>
</DL>
<HR>

<A NAME="getSource()"><!-- --></A><H3>
getSource</H3>
<PRE>
public java.lang.String <B>getSource</B>()</PRE>
<DL>
<DD>Returns the entire source.<DD><DL>
<DT><B>Returns:</B><DD>index of current position in source</DL>
</DD>
</DL>
<HR>

<A NAME="undoLast()"><!-- --></A><H3>
undoLast</H3>
<PRE>
public void <B>undoLast</B>()</PRE>
<DL>
<DD>This moves the current position to the position before the
 previous function was called.  This should work for all of the
 public functions.  It simple moves the current position to the
 position prior to the previous function.

 <p>This only works once.  In other words, currently only one
 undo operation is kept.</DL>
<HR>

<A NAME="isAt(java.lang.String)"><!-- --></A><H3>
isAt</H3>
<PRE>
public boolean <B>isAt</B>(java.lang.String&nbsp;regularExpression)
             throws gnu.regexp.REException</PRE>
<DL>
<DD>Indicates that the given regular expression will match the at
 current position.  This is useful if one wants to check the
 existance of optional text in the source at the current
 position.  The current position is not moved.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regularExpression</CODE> - to match at current position<DT><B>Returns:</B><DD>given expression matches at current position<DT><B>Throws:</B><DD>gnu.regexp.REException - if regularExpression is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="isAt(gnu.regexp.RE)"><!-- --></A><H3>
isAt</H3>
<PRE>
public boolean <B>isAt</B>(gnu.regexp.RE&nbsp;expression)</PRE>
<DL>
<DD>Indicates that the given regular expression will match the at
 current position.  This is useful if one wants to check the
 existance of optional text in the source at the current
 position.  The current position is not moved.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - to match at current position<DT><B>Returns:</B><DD>given expression matches at current position</DL>
</DD>
</DL>
<HR>

<A NAME="toPrintable(java.lang.String)"><!-- --></A><H3>
toPrintable</H3>
<PRE>
protected java.lang.String <B>toPrintable</B>(java.lang.String&nbsp;notPrintable)</PRE>
<DL>
<DD>Utility function to convert strings that have embedded non
 printable characters such as newlines and tabs, and returns a
 string that may be cleanly printed.  In other words, these
 characters are expanded to their printable character appearance
 like \n and \t.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>notPrintable</CODE> - string presumably containing tabs and newlines<DT><B>Returns:</B><DD>printable version of notPrintable with pretty tabs and newlines</DL>
</DD>
</DL>
<HR>

<A NAME="printTo(grace.io.PrintWriter)"><!-- --></A><H3>
printTo</H3>
<PRE>
public void <B>printTo</B>(<A HREF="../../grace/io/PrintWriter.html">PrintWriter</A>&nbsp;writer)</PRE>
<DL>
<DD>Used by grace.io.PrintWriter to nicely print this.</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD>toString in class java.lang.Object</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)</PRE>
<DL>
<DD>Test program not quite completed.</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../grace/util/Timer.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Tokenizer.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
