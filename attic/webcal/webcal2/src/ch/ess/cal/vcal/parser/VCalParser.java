/* Generated By:JavaCC: Do not edit this line. VCalParser.java */
package ch.ess.cal.vcal.parser;

import java.util.Iterator;

import ch.ess.cal.vcal.Field;
import ch.ess.cal.vcal.VCalendar;
import ch.ess.cal.vcal.VEvent;
import ch.ess.cal.vcal.VObject;
import ch.ess.cal.vcal.VTodo;

public class VCalParser implements VCalParserConstants {

  private VCalendar calendar = new VCalendar();
  private VObject ent;
  private Field fieldProperties;
  private String strParamName;
  private String strFieldName;

  //===========================================================================
  //===   STATIC CLASS METHODS   ==============================================

  public void addParamValue(String strValue) {
    fieldProperties.setFieldName(strFieldName);
    fieldProperties.setPropertyValue(strParamName, strValue);
  } // of addParamValue

  //===========================================================================

  public void addFieldValue(String strValue) {
    //// 1. Create a new field.
    Field field = new Field(strFieldName, strValue);

    //// 2. Copy all of the properties from the fieldProperty object over.
    Iterator enumeration = fieldProperties.getPropertyNames();
    String strKey;
    String strVal;
    while (enumeration.hasNext()) {
      strKey = (String)enumeration.next();
      strVal = fieldProperties.getPropertyValue(strKey);
      field.setPropertyValue(strKey, strVal);
    }

    //// 3. Add the entity.
    ent.addField(field);
    field = null;
  } // of addFieldValue

  //===========================================================================

  public void addAlarmField(String strRunTime, String strSnoozeTime, String strRepeatCount, String strContent) {

    String strVal;

    if (strRunTime == null) {
      strRunTime = " ";
    }
    if (strSnoozeTime == null) {
      strSnoozeTime = " ";
    }
    if (strRepeatCount == null) {
      strRepeatCount = " ";
    }
    if (strContent == null) {
      strContent = " ";
    }

    strVal = strRunTime + ";" + strSnoozeTime + ";" + strRepeatCount + ";" + strContent;
    addFieldValue(strVal);
  }

  //===========================================================================

  public void addCalendarEntity(VObject entity) {

    try {
      if (entity instanceof VEvent) {
        calendar.addNewEvent((VEvent)entity);
        entity = null;
      }
      if (entity instanceof VTodo) {
        calendar.addNewTodo((VTodo)entity);
        entity = null;
      }
    } catch (Exception e) {
      System.err.println("Error while parsing vCal data");
      System.err.println(e);
    }
  } // of addCalendarEntity

  //===   STATIC CLASS METHODS   ==============================================
  //===========================================================================

  //===========================================================================
  //===   SELF-TESTING MAIN   =================================================

  public void main(String argv[]) throws ParseException {
    VCalParser parser = new VCalParser(System.in);
    parser.Input();

    System.out.println();
    System.out.println(calendar);
  }

  //===   TOKENS   ===============================================================
  //==============================================================================

  //==============================================================================
  //===   INPUT   ================================================================
  final public VCalendar Input() throws ParseException {
    VCal();
    {
      if (true)
        return calendar;
    }
    throw new Error("Missing return statement in function");
  }

  // of Input

  /**
   * <PRE>
   * vcal_file = [wsls] vcal [wsls]
   * </PRE>
   */
  final public void VCalFile() throws ParseException {
    label_1 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACELN :
          
          break;
        default :
          jj_la1[0] = jj_gen;
          break label_1;
      }
      jj_consume_token(WSPACELN);
    }
    VCal();
    label_2 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACELN :
          
          break;
        default :
          jj_la1[1] = jj_gen;
          break label_2;
      }
      jj_consume_token(WSPACELN);
    }
  }

  // of VCalFile

  //==============================================================================

  /**
   * <PRE>
   * vcal = <BEGIN> [ws] ":" [ws] "VCALENDAR" [ws] 1*CRLF
   *        calprop calentities [ws] *CRLF
   *        <END>   [ws] ":" [ws] "VCALENDAR" [ws] 1*CRLF
   *
   * Fixed an error, should be "calprops" not "calprop".
   * Also, made "calentities" optional, as an empty calendar is conceivable.
   * </PRE>
   */
  final public void VCal() throws ParseException {
    jj_consume_token(BEGIN);
    label_3 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[2] = jj_gen;
          break label_3;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(COLON);
    label_4 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[3] = jj_gen;
          break label_4;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(VCALENDAR);
    label_5 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[4] = jj_gen;
          break label_5;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(15);
    CalProps();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BEGIN :
        CalEntities();
        break;
      default :
        jj_la1[5] = jj_gen;
        
    }
    jj_consume_token(END);
    label_6 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[6] = jj_gen;
          break label_6;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(COLON);
    label_7 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[7] = jj_gen;
          break label_7;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(VCALENDAR);
    label_8 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[8] = jj_gen;
          break label_8;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(15);
  }

  // of VCal

  //===   INPUT   ================================================================
  //==============================================================================

  //==============================================================================
  //===   CALENDAR PROPERTIES   ==================================================

  /**
   * <PRE>
   * calprops = calprops *CRLF calprop | calprop
   *
   * Modified to remove left-recursion.
   * </PRE>
   */
  final public void CalProps() throws ParseException {
    CalProp();
    label_9 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[9] = jj_gen;
          break label_9;
      }
      jj_consume_token(WSPACE);
    }
    label_10 : while (true) {
      jj_consume_token(15);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 15 :
          
          break;
        default :
          jj_la1[10] = jj_gen;
          break label_10;
      }
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 16 :
      case 17 :
      case 18 :
      case 19 :
      case 20 :
        CalProps();
        break;
      default :
        jj_la1[11] = jj_gen;
        
    }
  }

  // of CalProps

  /**
   * <PRE>
   * calprop = "DAYLIGHT" [params] ":" value CRLF
   *         | "GEO"      [params] ":" value CRLF
   *         | "PRODID"   [params] ":" value CRLF
   *         | "TZ"       [params] ":" value CRLF
   *         | "VERSION"  [params] ":" "1.0" CRLF
   *      ; The VERSION calendar property MUST appear in the vCalendar object.
   * </PRE>
   *
   * Currently ignoring GEO, DAYLIGHT, and PRODID.
   */
  final public void CalProp() throws ParseException {
    String str;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 16 :
        jj_consume_token(16);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[12] = jj_gen;
            
        }
        jj_consume_token(COLON);
        str = Value();
        break;
      case 17 :
        jj_consume_token(17);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[13] = jj_gen;
            
        }
        jj_consume_token(COLON);
        str = Value();
        break;
      case 18 :
        jj_consume_token(18);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[14] = jj_gen;
            
        }
        jj_consume_token(COLON);
        str = Value();
        break;
      case 19 :
        jj_consume_token(19);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[15] = jj_gen;
            
        }
        jj_consume_token(COLON);
        str = Value();
        calendar.setTimeZone(str);
        break;
      case 20 :
        jj_consume_token(20);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[16] = jj_gen;
            
        }
        jj_consume_token(COLON);
        jj_consume_token(21);
        break;
      default :
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  // of CalProp

  //===   CALENDAR PROPERTIES   ==================================================
  //==============================================================================

  //==============================================================================
  //===   CALENDAR ENTITIES   ====================================================

  /**
   * <PRE>
   * calentities     = calentities *CRLF calentity | calentity
   *
   * Modified to remove left-recursion. Also, modified to allow whitespace
   * between each calendar entity and the carriage-return linefeed because
   * of problems with ambiguity.
   * </PRE>
   */
  final public void CalEntities() throws ParseException {
    CalEntity();
    label_11 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[18] = jj_gen;
          break label_11;
      }
      jj_consume_token(WSPACE);
    }
    label_12 : while (true) {
      jj_consume_token(15);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 15 :
          
          break;
        default :
          jj_la1[19] = jj_gen;
          break label_12;
      }
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BEGIN :
        CalEntities();
        break;
      default :
        jj_la1[20] = jj_gen;
        
    }
  }

  // of CalEntities

  /**
   * <PRE>
   * calentity       = evententity | TODOentity
   * </PRE>
   */
  final public VObject CalEntity() throws ParseException {
    jj_consume_token(BEGIN);
    label_13 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[21] = jj_gen;
          break label_13;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(COLON);
    label_14 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[22] = jj_gen;
          break label_14;
      }
      jj_consume_token(WSPACE);
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VEVENT :
        ent = EventEntity();
        break;
      case VTODO :
        ent = TodoEntity();
        break;
      default :
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    addCalendarEntity(ent);
    {
      if (true)
        return (ent);
    }
    throw new Error("Missing return statement in function");
  }

  // of CalEntity

  //==============================================================================

  /**
   * <PRE>
   * evententity = <BEGIN> [ws] ":" [ws] "EVENT" [ws] 1*CRLF
   *               entprops [ws] *CRLF
   *               <END>   [ws] ":" [ws] "EVENT" [ws] 1*CRLF
   *
   * I think that there's an error, that it should be "VEVENT" not "EVENT"
   *
   * Modified to have opening part (<BEGIN> [ws] ":" [ws]) to be part of
   * CalEntity() since TodoEntity() has the same opening.
   *
   * Also, whitespace and carriage-return linefeed following EntProps() moved
   * to inside EntProps().
   * </PRE>
   */
  final public VObject EventEntity() throws ParseException {
    ent = new VEvent();
    jj_consume_token(VEVENT);
    label_15 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[24] = jj_gen;
          break label_15;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(15);
    EntProps();
    jj_consume_token(END);
    label_16 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[25] = jj_gen;
          break label_16;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(COLON);
    label_17 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[26] = jj_gen;
          break label_17;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(VEVENT);
    {
      if (true)
        return ent;
    }
    throw new Error("Missing return statement in function");
  }

  // of EventEntity

  //==============================================================================

  /**
   * <PRE>
   * TODOentity = <BEGIN>  [ws] ":" [ws] "TODO" [ws] 1*CRLF
   *              entprops [ws] *CRLF
   *              <END>    [ws] ":" [ws] "TODO" [ws] 1*CRLF
   *
   * Modified from "TODO" to "VTODO".
   *
   * Modified to have opening part (<BEGIN> [ws] ":" [ws]) to be part of
   * CalEntity() since EventEntity() has the same opening.
   *
   * Also, whitespace and carriage-return linefeed following EntProps() moved
   * to inside EntProps().
   * </PRE>
   */
  final public VObject TodoEntity() throws ParseException {
    ent = new VTodo();
    jj_consume_token(VTODO);
    label_18 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[27] = jj_gen;
          break label_18;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(15);
    EntProps();
    jj_consume_token(END);
    label_19 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[28] = jj_gen;
          break label_19;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(COLON);
    label_20 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[29] = jj_gen;
          break label_20;
      }
      jj_consume_token(WSPACE);
    }
    jj_consume_token(VTODO);
    {
      if (true)
        return ent;
    }
    throw new Error("Missing return statement in function");
  }

  // of TodoEntity

  //===   CALENDAR ENTITIES   ====================================================
  //==============================================================================

  //==============================================================================
  //===   ENTITY PROPERTIES   ====================================================

  /**
   * <PRE>
   * entprops        = entprops *CRLF entprop | entprop
   *
   * Modified to remove left-recursion. Also, modified to allow whitespace
   * between each calendar entity and the carriage-return linefeed because
   * of problems with ambiguity.
   * </PRE>
   */
  final public void EntProps() throws ParseException {
    EntProp();
    label_21 : while (true) {
      jj_consume_token(15);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 15 :
          
          break;
        default :
          jj_la1[30] = jj_gen;
          break label_21;
      }
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WSPACE :
      case 22 :
      case 23 :
      case 24 :
      case 25 :
      case 26 :
      case 27 :
      case 28 :
      case 29 :
      case 30 :
      case 31 :
      case 32 :
      case 33 :
      case 34 :
      case 35 :
      case 36 :
      case 37 :
      case 38 :
      case 39 :
      case 40 :
      case 41 :
      case 42 :
      case 43 :
      case 44 :
      case 45 :
      case 46 :
      case 47 :
      case 48 :
      case 49 :
      case 50 :
      case 51 :
      case 52 :
        EntProps();
        break;
      default :
        jj_la1[31] = jj_gen;
        
    }
  }

  // of EntProps

  /**
   * <PRE>
   * entprop = [ws] simprop      [params] ":"   value       CRLF
   *         | [ws] "AALARM"     [params] ":"   aalarmparts CRLF
   *         | [ws] "CATEGORIES" [params] ":" 1*catvals     CRLF
   *         | [ws] "CLASS"      [params] ":"   classvals   CRLF
   *         | [ws] "DALARM"     [params] ":"   dalarmparts CRLF
   *         | [ws] "EXDATE"     [params] ":"   xdatevals   CRLF
   *         | [ws] "MALARM"     [params] ":"   malarmparts CRLF
   *         | [ws] "PALARM"     [params] ":"   palarmparts CRLF
   *         | [ws] "RDATE"      [params] ":"   rdatevals   CRLF
   *         | [ws] "RESOURCES"  [params] ":" 1*resvals     CRLF
   *         | [ws] "STATUS"     [params] ":"   statvals    CRLF
   *
   * Changed from Value to ValueList since some properties are separable
   * by semicolons.
   *
   * </PRE>
   */
  final public void EntProp() throws ParseException {
    fieldProperties = new Field();
    label_22 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[32] = jj_gen;
          break label_22;
      }
      jj_consume_token(WSPACE);
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 32 :
      case 33 :
      case 34 :
      case 35 :
      case 36 :
      case 37 :
      case 38 :
      case 39 :
      case 40 :
      case 41 :
      case 42 :
      case 43 :
      case 44 :
      case 45 :
      case 46 :
      case 47 :
      case 48 :
      case 49 :
      case 50 :
      case 51 :
      case 52 :
        SimProp();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[33] = jj_gen;
            
        }
        jj_consume_token(COLON);
        ValueList();
        break;
      case 22 :
        jj_consume_token(22);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[34] = jj_gen;
            
        }
        jj_consume_token(COLON);
        AAlarmParts();
        break;
      case 23 :
        jj_consume_token(23);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[35] = jj_gen;
            
        }
        jj_consume_token(COLON);
        CatValsList();
        break;
      case 24 :
        jj_consume_token(24);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[36] = jj_gen;
            
        }
        jj_consume_token(COLON);
        ClassVals();
        break;
      case 25 :
        jj_consume_token(25);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[37] = jj_gen;
            
        }
        jj_consume_token(COLON);
        DAlarmParts();
        break;
      case 26 :
        jj_consume_token(26);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[38] = jj_gen;
            
        }
        jj_consume_token(COLON);
        XDateValsList();
        break;
      case 27 :
        jj_consume_token(27);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[39] = jj_gen;
            
        }
        jj_consume_token(COLON);
        MAlarmParts();
        break;
      case 28 :
        jj_consume_token(28);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[40] = jj_gen;
            
        }
        jj_consume_token(COLON);
        PAlarmParts();
        break;
      case 29 :
        jj_consume_token(29);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[41] = jj_gen;
            
        }
        jj_consume_token(COLON);
        RDateValsList();
        break;
      case 30 :
        jj_consume_token(30);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[42] = jj_gen;
            
        }
        jj_consume_token(COLON);
        ResValsList();
        break;
      case 31 :
        jj_consume_token(31);
        strFieldName = token.toString();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON :
            Params();
            break;
          default :
            jj_la1[43] = jj_gen;
            
        }
        jj_consume_token(COLON);
        StatVals();
        break;
      default :
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  // of EntProp

  //==============================================================================

  /**
   * <PRE>
   * simprop = "ATTACH" | "ATTENDEE" | "DCREATED" | "COMPLETED" 
   *           | "DESCRIPTION" | "DUE" | "DTEND" | "EXRULE" | "LAST-MODIFIED"
   *           | "LOCATION" | "RNUM" | "PRIORITY" | "RELATED-TO" | "RRULE" 
   *           | "SEQUENCE" | "DTSTART" | "SUMMARY" | "TRANSP" | "URL" 
   *           | "UID" |"X-" word
   * </PRE>
   */
  final public void SimProp() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 32 :
        jj_consume_token(32);
        break;
      case 33 :
        jj_consume_token(33);
        break;
      case 34 :
        jj_consume_token(34);
        break;
      case 35 :
        jj_consume_token(35);
        break;
      case 36 :
        jj_consume_token(36);
        break;
      case 37 :
        jj_consume_token(37);
        break;
      case 38 :
        jj_consume_token(38);
        break;
      case 39 :
        jj_consume_token(39);
        break;
      case 40 :
        jj_consume_token(40);
        break;
      case 41 :
        jj_consume_token(41);
        break;
      case 42 :
        jj_consume_token(42);
        break;
      case 43 :
        jj_consume_token(43);
        break;
      case 44 :
        jj_consume_token(44);
        break;
      case 45 :
        jj_consume_token(45);
        break;
      case 46 :
        jj_consume_token(46);
        break;
      case 47 :
        jj_consume_token(47);
        break;
      case 48 :
        jj_consume_token(48);
        break;
      case 49 :
        jj_consume_token(49);
        break;
      case 50 :
        jj_consume_token(50);
        break;
      case 51 :
        jj_consume_token(51);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      default :
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (str == null) {
      strFieldName = token.toString();
    } else {
      strFieldName = str;
    }
  }

  //==============================================================================

  /**
   * <PRE>
   * aalarmparts = 0*3(strnosemi ";") strnosemi 
   *    ; runTime, snoozeTime, repeatCount, audioContent
   * </PRE>
   */
  final public void AAlarmParts() throws ParseException {
    String strRunTime;
    String strSnoozeTime;
    String strRepeatCount;
    String strContent;
    strRunTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strSnoozeTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strRepeatCount = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strContent = StrNoSemi();
    addAlarmField(strRunTime, strSnoozeTime, strRepeatCount, strContent);
  }

  //==============================================================================

  /**
   * This part was added since the examples show that categories can
   * be a list of categories, for example:
   *
   * <PRE>
   * CATEGORIES:APPOINTMENT;BUSINESS;
   * </PRE>
   */
  final public void CatValsList() throws ParseException {
    CatVals();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_23 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[46] = jj_gen;
              break label_23;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_24 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[47] = jj_gen;
              break label_24;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
          case 52 :
          case 53 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
          case 58 :
          case 59 :
          case 60 :
          case 61 :
          case 62 :
          case 63 :
          case 64 :
            CatValsList();
            break;
          default :
            jj_la1[48] = jj_gen;
            
        }
        break;
      default :
        jj_la1[49] = jj_gen;
        
    }
  }

  /**
   * <PRE>
   * catvals = "APPOINTMENT" | "BUSINESS" | "EDUCATION" | "HOLIDAY" | "MEETING" 
   *           | "MISCELLANEOUS" | "PERSONAL" | "PHONE CALL" | "SICK DAY"
   *           | "SPECIAL OCCASION" | "TRAVEL" | "VACATION" | "X-" word | value
   * </PRE>
   *
   * The parentheses around the list is very important, a one-hour debugging
   * and tracing lesson. If they are not there, then the system will just
   * match and leave without executing the code beneath.
   */
  final public void CatVals() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 53 :
        jj_consume_token(53);
        break;
      case 54 :
        jj_consume_token(54);
        break;
      case 55 :
        jj_consume_token(55);
        break;
      case 56 :
        jj_consume_token(56);
        break;
      case 57 :
        jj_consume_token(57);
        break;
      case 58 :
        jj_consume_token(58);
        break;
      case 59 :
        jj_consume_token(59);
        break;
      case 60 :
        jj_consume_token(60);
        break;
      case 61 :
        jj_consume_token(61);
        break;
      case 62 :
        jj_consume_token(62);
        break;
      case 63 :
        jj_consume_token(63);
        break;
      case 64 :
        jj_consume_token(64);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (str == null) {
      str = token.toString();
    }
    addFieldValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * classvals = "PUBLIC" | "PRIVATE" | "CONFIDENTIAL" | "X-" word | value
   * </PRE>
   */
  final public void ClassVals() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 65 :
        jj_consume_token(65);
        break;
      case 66 :
        jj_consume_token(66);
        break;
      case 67 :
        jj_consume_token(67);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (str == null) {
      str = token.toString();
    }
    addFieldValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * dalarmparts     = 0*3(strnosemi ";") strnosemi
   *                ; runTime, snoozeTime, repeatCount, displayString
   * </PRE>
   */
  final public void DAlarmParts() throws ParseException {
    String strRunTime;
    String strSnoozeTime;
    String strRepeatCount;
    String strContent;
    strRunTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strSnoozeTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strRepeatCount = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strContent = StrNoSemi();
    addAlarmField(strRunTime, strSnoozeTime, strRepeatCount, strContent);
  }

  //==============================================================================
  final public void XDateValsList() throws ParseException {
    XDateVals();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_25 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[52] = jj_gen;
              break label_25;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_26 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[53] = jj_gen;
              break label_26;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
            XDateValsList();
            break;
          default :
            jj_la1[54] = jj_gen;
            
        }
        break;
      default :
        jj_la1[55] = jj_gen;
        
    }
  }

  /**
   * <PRE>
   * xdatevals       = 1*value
   *         ; One or more date|time values
   *
   * The grammar provided in the spec doesn't say so, but each of the
   * dates here should be separated by a semicolon (as in the example
   * EXDATE:19960402T010000Z;19960403T010000Z;19960404T010000Z).
   * </PRE>
   */
  final public void XDateVals() throws ParseException {
    String str;
    str = Value();
    addFieldValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * malarmparts     = 0*4(strnosemi ";") strnosemi
   *         ; runTime, snoozeTime, repeatCount, addressString, noteString
   * </PRE>
   */
  final public void MAlarmParts() throws ParseException {
    String strRunTime;
    String strSnoozeTime;
    String strRepeatCount;
    String strAddr;
    String strNote;
    strRunTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strSnoozeTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strRepeatCount = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strAddr = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strNote = StrNoSemi();
    addAlarmField(strRunTime, strSnoozeTime, strRepeatCount, strAddr + ";" + strNote);
  }

  //==============================================================================

  /**
   * <PRE>
   * palarmparts     = 0*3(strnosemi ";") strnosemi
   *         ; runTime, snoozeTime, repeatCount, procedureName
   * </PRE>
   */
  final public void PAlarmParts() throws ParseException {
    String strRunTime;
    String strSnoozeTime;
    String strRepeatCount;
    String strContent;
    strRunTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strSnoozeTime = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strRepeatCount = StrNoSemi();
    jj_consume_token(SEMICOLON);
    strContent = StrNoSemi();
    addAlarmField(strRunTime, strSnoozeTime, strRepeatCount, strContent);
  }

  //==============================================================================
  final public void RDateValsList() throws ParseException {
    RDateVals();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_27 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[56] = jj_gen;
              break label_27;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_28 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[57] = jj_gen;
              break label_28;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
            RDateValsList();
            break;
          default :
            jj_la1[58] = jj_gen;
            
        }
        break;
      default :
        jj_la1[59] = jj_gen;
        
    }
  }

  /**
   * <PRE>
   * rdatevals       = 1*value
   *         ; One or more date|time values
   *
   * The grammar provided in the spec doesn't say so, but each of the
   * dates here should be separated by a semicolon (as in the example
   * RDATE:19960402T010000Z;19960403T010000Z;19960404T010000Z
   * </PRE>
   */
  final public void RDateVals() throws ParseException {
    String str;
    str = Value();
    addFieldValue(str);
  }

  //==============================================================================
  final public void ResValsList() throws ParseException {
    ResVals();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_29 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[60] = jj_gen;
              break label_29;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_30 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[61] = jj_gen;
              break label_30;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
          case 52 :
          case 68 :
          case 69 :
          case 70 :
          case 71 :
          case 72 :
          case 73 :
            ResValsList();
            break;
          default :
            jj_la1[62] = jj_gen;
            
        }
        break;
      default :
        jj_la1[63] = jj_gen;
        
    }
  }

  /**
   * <PRE>
   * resvals = "CATERING" | "CHAIRS" | "EASEL" | "PROJECTOR" | "VCR" 
   *                 | "VEHICLE" | "X-" word | value
   *
   * Example: RESOURCES:EASEL;PROJECTOR;VCR
   * </PRE>
   */
  final public void ResVals() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 68 :
        jj_consume_token(68);
        break;
      case 69 :
        jj_consume_token(69);
        break;
      case 70 :
        jj_consume_token(70);
        break;
      case 71 :
        jj_consume_token(71);
        break;
      case 72 :
        jj_consume_token(72);
        break;
      case 73 :
        jj_consume_token(73);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (str == null) {
      str = token.toString();
    }
    addFieldValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * statvals        = "ACCEPTED" | "NEEDS ACTION" | "SENT" | "TENTATIVE"
   *                 | "CONFIRMED" | "DECLINED" | "COMPLETED" | "DELEGATED"
   *                 | "X-" word | value
   * </PRE>
   */
  final public void StatVals() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 74 :
        jj_consume_token(74);
        break;
      case 75 :
        jj_consume_token(75);
        break;
      case 76 :
        jj_consume_token(76);
        break;
      case 77 :
        jj_consume_token(77);
        break;
      case 78 :
        jj_consume_token(78);
        break;
      case 79 :
        jj_consume_token(79);
        break;
      case 35 :
        jj_consume_token(35);
        break;
      case 80 :
        jj_consume_token(80);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (str == null) {
      str = token.toString();
    }
    addFieldValue(str);
  }

  //===   ENTITY PROPERTIES   ====================================================
  //==============================================================================

  //==============================================================================
  //===   PARAMETERS   ===========================================================

  /**
   * <PRE>
   * params          = ";" [ws] paramlist
   * </PRE>
   */
  final public void Params() throws ParseException {
    jj_consume_token(SEMICOLON);
    label_31 : while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WSPACE :
          
          break;
        default :
          jj_la1[66] = jj_gen;
          break label_31;
      }
      jj_consume_token(WSPACE);
    }
    ParamList();
  }

  //==============================================================================

  /**
   * <PRE>
   * paramlist       = paramlist [ws] ";" [ws] param
   *                 | param
   *
   * Modified to remove left-recursion.
   * </PRE>
   */
  final public void ParamList() throws ParseException {
    Param();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_32 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[67] = jj_gen;
              break label_32;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_33 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[68] = jj_gen;
              break label_33;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
          case 31 :
          case 52 :
          case 81 :
          case 82 :
          case 83 :
          case 84 :
          case 85 :
          case 86 :
          case 87 :
          case 88 :
          case 89 :
          case 90 :
          case 91 :
            ParamList();
            break;
          default :
            jj_la1[69] = jj_gen;
            
        }
        break;
      default :
        jj_la1[70] = jj_gen;
        
    }
  }

  //==============================================================================

  /**
   * <PRE>
   * param           = "TYPE"      [ws] "=" [ws]  ptypeval
   *                 | ["VALUE"    [ws] "=" [ws]] pvalueval
   *                 | ["ENCODING" [ws] "=" [ws]] pencodingval
   *                 | "CHARSET"   [ws] "=" [ws]  charsetval
   *                 | "LANGUAGE"  [ws] "=" [ws]  langval
   *                 | "ROLE"      [ws] "=" [ws]  roleval
   *                 | "STATUS"    [ws] "=" [ws]  statusval
   *                 | "X-" word   [ws] "=" [ws]  word
   *                 | knowntype
   *
   * This has been modified to make "VALUE" and "ENCODING" necessary,
   * since it leads to ambiguity for "X- Word()" if it's not there.
   *
   * PTypeVal() for "TYPE" has been replaced by KnownType(), since
   * they're pretty much the same.
   *
   * Added "RSVP" and "EXPECT" since their in the spec but not in the grammar.
   *
   * Changed "KnownType()" into "KnownVal()" and "KnownType" since they have
   * the same values but are used in two different ways.
   * </PRE>
   */
  final public void Param() throws ParseException {
    String str;
    if (jj_2_1(10)) {
      jj_consume_token(52);
      str = Word();
      strParamName = "X-" + str;
      label_34 : while (true) {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case WSPACE :
            
            break;
          default :
            jj_la1[71] = jj_gen;
            break label_34;
        }
        jj_consume_token(WSPACE);
      }
      jj_consume_token(EQUALS);
      label_35 : while (true) {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case WSPACE :
            
            break;
          default :
            jj_la1[72] = jj_gen;
            break label_35;
        }
        jj_consume_token(WSPACE);
      }
      Word();
    } else {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 81 :
          jj_consume_token(81);
          strParamName = token.toString();
          label_36 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[73] = jj_gen;
                break label_36;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_37 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[74] = jj_gen;
                break label_37;
            }
            jj_consume_token(WSPACE);
          }
          KnownVal();
          break;
        case 82 :
          jj_consume_token(82);
          strParamName = token.toString();
          label_38 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[75] = jj_gen;
                break label_38;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_39 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[76] = jj_gen;
                break label_39;
            }
            jj_consume_token(WSPACE);
          }
          PValueVal();
          break;
        case 83 :
          jj_consume_token(83);
          strParamName = token.toString();
          label_40 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[77] = jj_gen;
                break label_40;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_41 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[78] = jj_gen;
                break label_41;
            }
            jj_consume_token(WSPACE);
          }
          PEncodingVal();
          break;
        case 84 :
          jj_consume_token(84);
          strParamName = token.toString();
          label_42 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[79] = jj_gen;
                break label_42;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_43 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[80] = jj_gen;
                break label_43;
            }
            jj_consume_token(WSPACE);
          }
          CharSetVal();
          break;
        case 85 :
          jj_consume_token(85);
          strParamName = token.toString();
          label_44 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[81] = jj_gen;
                break label_44;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_45 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[82] = jj_gen;
                break label_45;
            }
            jj_consume_token(WSPACE);
          }
          LangVal();
          break;
        case 86 :
          jj_consume_token(86);
          strParamName = token.toString();
          label_46 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[83] = jj_gen;
                break label_46;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_47 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[84] = jj_gen;
                break label_47;
            }
            jj_consume_token(WSPACE);
          }
          RoleVal();
          break;
        case 31 :
          jj_consume_token(31);
          strParamName = token.toString();
          label_48 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[85] = jj_gen;
                break label_48;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_49 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[86] = jj_gen;
                break label_49;
            }
            jj_consume_token(WSPACE);
          }
          StatusVal();
          break;
        case 87 :
          jj_consume_token(87);
          strParamName = token.toString();
          label_50 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[87] = jj_gen;
                break label_50;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_51 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[88] = jj_gen;
                break label_51;
            }
            jj_consume_token(WSPACE);
          }
          RSVPVal();
          break;
        case 88 :
          jj_consume_token(88);
          strParamName = token.toString();
          label_52 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[89] = jj_gen;
                break label_52;
            }
            jj_consume_token(WSPACE);
          }
          jj_consume_token(EQUALS);
          label_53 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case WSPACE :
                
                break;
              default :
                jj_la1[90] = jj_gen;
                break label_53;
            }
            jj_consume_token(WSPACE);
          }
          ExpectVal();
          break;
        case NONSEMI :
        case 52 :
        case 89 :
        case 90 :
        case 91 :
          KnownType();
          break;
        default :
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    }
  }

  //==============================================================================

  /**
   * <PRE>
   * ptypeval        = knowntype | "X-" word
   *
   * This rule seems completely useless, as it is subsumed by KnownType().
   * That's why I'm getting rid of it.
   * </PRE>
   */
  /*
  void PTypeVal(): {}
  {
     (KnownType() | "X-" Word())
  }
  */

  //==============================================================================

  /**
   * <PRE>
   * knowntype       = "WAVE" | "PCM" | "VCARD" | "X-" word | value
   * </PRE>
   */
  final public void KnownType() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 89 :
        jj_consume_token(89);
        break;
      case 90 :
        jj_consume_token(90);
        break;
      case 91 :
        jj_consume_token(91);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    strParamName = str;
  }

  //==============================================================================

  /**
   * <PRE>
   * knowntype       = "WAVE" | "PCM" | "VCARD" | "X-" word | value
   * </PRE>
   */
  final public void KnownVal() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 89 :
        jj_consume_token(89);
        break;
      case 90 :
        jj_consume_token(90);
        break;
      case 91 :
        jj_consume_token(91);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      case NONSEMI :
        str = Value();
        break;
      default :
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * pvalueval       = "INLINE" | "URL" | "CONTENT-ID" | "CID" | "X-" word
   * </PRE>
   */
  final public void PValueVal() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 92 :
        jj_consume_token(92);
        break;
      case 50 :
        jj_consume_token(50);
        break;
      case 93 :
        jj_consume_token(93);
        break;
      case 94 :
        jj_consume_token(94);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      default :
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * pencodingval = "7BIT" | "8BIT" | "QUOTED-PRINTABLE" | "BASE64" | "X-" word
   * </PRE>
   */
  final public void PEncodingVal() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 95 :
        jj_consume_token(95);
        break;
      case 96 :
        jj_consume_token(96);
        break;
      case 97 :
        jj_consume_token(97);
        break;
      case 98 :
        jj_consume_token(98);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      default :
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * charsetval = <a character set string as defined in Section 7.1 of RFC 1521>
   * </PRE>
   */
  final public void CharSetVal() throws ParseException {
    String str = null;
    str = StrNoSemi();
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * langval = <a language string as defined in RFC 1766>
   * </PRE>
   */
  final public void LangVal() throws ParseException {
    String str = null;
    str = StrNoSemi();
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * roleval = "ATTENDEE" | "ORGANIZER" | "OWNER" | "X-" word
   * </PRE>
   *
   * Added "DELEGATE" since it's in the spec.
   */
  final public void RoleVal() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 33 :
        jj_consume_token(33);
        break;
      case 99 :
        jj_consume_token(99);
        break;
      case 100 :
        jj_consume_token(100);
        break;
      case 101 :
        jj_consume_token(101);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      default :
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    addParamValue(str);
  }

  //==============================================================================

  /**
   * <PRE>
   * statusval = "ACCEPTED" | "NEEDS ACTION" | "SENT" | "TENTATIVE" 
   *          | "CONFIRMED" | "DECLINED" | "COMPLETED" | "DELEGATED" | "X-" word
   * </PRE>
   */
  final public void StatusVal() throws ParseException {
    String str = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 74 :
        jj_consume_token(74);
        break;
      case 75 :
        jj_consume_token(75);
        break;
      case 76 :
        jj_consume_token(76);
        break;
      case 77 :
        jj_consume_token(77);
        break;
      case 78 :
        jj_consume_token(78);
        break;
      case 79 :
        jj_consume_token(79);
        break;
      case 35 :
        jj_consume_token(35);
        break;
      case 80 :
        jj_consume_token(80);
        break;
      case 52 :
        jj_consume_token(52);
        str = Word();
        str = "X-" + str;
        break;
      default :
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    //// Set the parameter field name.
    if (str == null) {
      str = token.toString();
    }
    addParamValue(str);
  }

  //==============================================================================

  /**
   * This is in the spec but not in the grammar.
   */
  final public void RSVPVal() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 102 :
        jj_consume_token(102);
        break;
      case 103 :
        jj_consume_token(103);
        break;
      default :
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    addParamValue(token.toString());
  }

  //==============================================================================

  /**
   * This is in the spec but not in the grammar.
   */
  final public void ExpectVal() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case 104 :
        jj_consume_token(104);
        break;
      case 105 :
        jj_consume_token(105);
        break;
      case 106 :
        jj_consume_token(106);
        break;
      case 107 :
        jj_consume_token(107);
        break;
      default :
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    addParamValue(token.toString());
  }

  //===   PARAMETERS   ===========================================================
  //==============================================================================

  //==============================================================================
  //===   STRINGS   ==============================================================

  /**
   * <PRE>
   * strnosemi       = *(*nonsemi ("\;" | "\" CRLF)) *nonsemi
   *         ; To include a semicolon in this string, it must be escaped
   *         ; with a "\" character.
   * </PRE>
   */
  final public String StrNoSemi() throws ParseException {
    StringBuffer strbuf = new StringBuffer();
    label_54 : while (true) {
      jj_consume_token(NONSEMI);
      strbuf.append(token.toString());
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NONSEMI :
          
          break;
        default :
          jj_la1[100] = jj_gen;
          break label_54;
      }
    }
    {
      if (true)
        return strbuf.toString();
    }
    throw new Error("Missing return statement in function");
  }

  //======================================

  /**
   * nonsemi         = <any non-control ASCII except ";">
   */

  //======================================

  /**
   * quoted-printable = <MIME RFC 1521 quoted-printable text>
   */

  //======================================

  /**
   * word            = <any printable 7bit us-ascii except []=:., >
   */
  final public String Word() throws ParseException {
    StringBuffer strbuf = new StringBuffer();
    label_55 : while (true) {
      jj_consume_token(NONSEMI);
      strbuf.append(token.toString());
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NONSEMI :
          
          break;
        default :
          jj_la1[101] = jj_gen;
          break label_55;
      }
    }
    {
      if (true)
        return strbuf.toString();
    }
    throw new Error("Missing return statement in function");
  }

  //======================================

  /**
   * <PRE>
   * base64          = <MIME RFC 1521 base64 text>
   *         ; the end of the text is marked with two CRLF sequences
   *         ; this results in one blank line before the start of the next
   *         ; property
   * </PRE>
   */
  /*
  void TextBase64(): 
     { StringBuffer strbuf = new StringBuffer(); }
  {
     < BASE64: (~[])+ "\r\n\r\n" >
  }
  */

  //======================================
  final public void ValueList() throws ParseException {
    String str = null;
    str = Value();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SEMICOLON :
      case WSPACE :
        label_56 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[102] = jj_gen;
              break label_56;
          }
          jj_consume_token(WSPACE);
        }
        jj_consume_token(SEMICOLON);
        label_57 : while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WSPACE :
              
              break;
            default :
              jj_la1[103] = jj_gen;
              break label_57;
          }
          jj_consume_token(WSPACE);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case NONSEMI :
            ValueList();
            break;
          default :
            jj_la1[104] = jj_gen;
            
        }
        break;
      default :
        jj_la1[105] = jj_gen;
        
    }
    if (str == null) {
      str = token.toString();
    }
    addFieldValue(str);
  }

  /**
   * value = 7bit / 8bit / quoted-printable / base64
   *  ; The value must be in the encoding type specified for the property value.
   */
  final public String Value() throws ParseException {
    StringBuffer strbuf = new StringBuffer();
    label_58 : while (true) {
      jj_consume_token(NONSEMI);
      strbuf.append(token.toString());
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NONSEMI :
          
          break;
        default :
          jj_la1[106] = jj_gen;
          break label_58;
      }
    }
    {
      if (true)
        return strbuf.toString();
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(WSPACE))
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(WSPACE))
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(NONSEMI))
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    return false;
  }

  final private boolean jj_3R_59() {
    Token xsp;
    if (jj_3R_62())
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_62()) {
        jj_scanpos = xsp;
        break;
      }
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
        return false;
    }
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(52))
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    if (jj_3R_59())
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_60()) {
        jj_scanpos = xsp;
        break;
      }
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
        return false;
    }
    if (jj_scan_token(EQUALS))
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) {
        jj_scanpos = xsp;
        break;
      }
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
        return false;
    }
    if (jj_3R_59())
      return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos)
      return false;
    return false;
  }

  public VCalParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  
  private int jj_gen;
  final private int[] jj_la1 = new int[107];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
    jj_la1_0();
    jj_la1_1();
    jj_la1_2();
    jj_la1_3();
  }
  private static void jj_la1_0() {
    jj_la1_0 =
      new int[] {
        0x800,
        0x800,
        0x400,
        0x400,
        0x400,
        0x2,
        0x400,
        0x400,
        0x400,
        0x400,
        0x8000,
        0x1f0000,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x1f0000,
        0x400,
        0x8000,
        0x2,
        0x400,
        0x400,
        0x30,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x8000,
        0xffc00400,
        0x400,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0x80,
        0xffc00000,
        0x0,
        0x400,
        0x400,
        0x200,
        0x480,
        0x200,
        0x200,
        0x400,
        0x400,
        0x200,
        0x480,
        0x400,
        0x400,
        0x200,
        0x480,
        0x400,
        0x400,
        0x200,
        0x480,
        0x200,
        0x200,
        0x400,
        0x400,
        0x400,
        0x80000200,
        0x480,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x400,
        0x80000200,
        0x200,
        0x200,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x200,
        0x200,
        0x400,
        0x400,
        0x200,
        0x480,
        0x200,
        };
  }
  private static void jj_la1_1() {
    jj_la1_1 =
      new int[] {
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x1fffff,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x1fffff,
        0x1fffff,
        0x0,
        0x0,
        0xfff00000,
        0x0,
        0xfff00000,
        0x100000,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x100000,
        0x0,
        0x100000,
        0x100008,
        0x0,
        0x0,
        0x0,
        0x100000,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x100000,
        0x100000,
        0x100000,
        0x140000,
        0x100000,
        0x100002,
        0x100008,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        };
  }
  private static void jj_la1_2() {
    jj_la1_2 =
      new int[] {
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x1,
        0x0,
        0x1,
        0xe,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x3f0,
        0x0,
        0x3f0,
        0x1fc00,
        0x0,
        0x0,
        0x0,
        0xffe0000,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0xffe0000,
        0xe000000,
        0xe000000,
        0x70000000,
        0x80000000,
        0x0,
        0x1fc00,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        };
  }
  private static void jj_la1_3() {
    jj_la1_3 =
      new int[] {
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x7,
        0x38,
        0x0,
        0xc0,
        0xf00,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        };
  }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public VCalParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new VCalParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  public VCalParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new VCalParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  public VCalParser(VCalParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(VCalParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 107; i++)
      jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++)
      jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen)
              c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0;
      Token tok = token;
      while (tok != null && tok != jj_scanpos) {
        i++;
        tok = tok.next;
      }
      if (tok != null)
        jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt = token.next) == null)
      return (jj_ntk = (token.next = token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100)
      return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enumeration = jj_expentries.elements(); enumeration.hasMoreElements();) {
        int[] oldentry = (int[]) (enumeration.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists)
            break;
        }
      }
      if (!exists)
        jj_expentries.addElement(jj_expentry);
      if (pos != 0)
        jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[108];
    for (int i = 0; i < 108; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 107; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1 << j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1 << j)) != 0) {
            la1tokens[32 + j] = true;
          }
          if ((jj_la1_2[i] & (1 << j)) != 0) {
            la1tokens[64 + j] = true;
          }
          if ((jj_la1_3[i] & (1 << j)) != 0) {
            la1tokens[96 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 108; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
    //no action
  }

  final public void disable_tracing() {
    //no action
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg;
          jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0 :
              jj_3_1();
              break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) {
        p = p.next = new JJCalls();
        break;
      }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la;
    p.first = token;
    p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

  // of main

  //===   SELF-TESTING MAIN   =================================================
  //===========================================================================

}
