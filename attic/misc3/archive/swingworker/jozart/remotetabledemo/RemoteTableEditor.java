/*
 * RemoteTableEditor.java
 * 
 * Originally written by Joseph Bowbeer and released into the public domain.
 * This may be used for any purposes whatsoever without acknowledgment.
 */

package jozart.remotetabledemo;

import java.awt.*;
import java.awt.event.*;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.rmi.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;

import jozart.remotetable.*;
import common.swing.*;
import EDU.oswego.cs.dl.util.concurrent.*;
import jozart.swingutils.*;

/**
 * Edits a remote table model. 
 *
 * @author  Joseph Bowbeer
 * @version 1.0
 */
public class RemoteTableEditor extends javax.swing.JApplet {

// Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JPanel jPanel;
    private javax.swing.JLabel jlblStatus;
    private Blip blip;
// End of variables declaration//GEN-END:variables

    private RemoteTable remoteTable;

    /** Number of active tasks. */
    private int activeTasks;

    /** Initializes the form. */
    public RemoteTableEditor() {
        initComponents();

        /* NetBeans generated the following, but I couldn't save
           the form because JTable wouldn't serialize itself. */
        remoteTable = new RemoteTable ();
        remoteTable.setPreferredScrollableViewportSize (new java.awt.Dimension(450, 150));
        remoteTable.addRemoteTableTaskListener (new RemoteTableTaskListener () {
            public void taskStarted (RemoteTableTaskEvent evt) {
                remoteTableTaskStarted (evt);
            }
            public void taskEnded (RemoteTableTaskEvent evt) {
                remoteTableTaskEnded (evt);
            }
        });
        jScrollPane.add (remoteTable);
        jScrollPane.setViewportView (remoteTable);
        /* */

        /* Setup local table model, listen for changes. */
        DefaultTableModel model = createLocalModel ();
        model.addTableModelListener (new TableModelListener () {
            public void tableChanged (TableModelEvent evt) {
                localTableChanged (evt);
            }
        });
        remoteTable.setModel (model);

        /* Install an editor for Integer cells. */
        remoteTable.setDefaultEditor (Integer.class, new IntegerCellEditor());
    }

    /**
     * Called from within the constructor to initialize the form.
     * The content of this method is generated by NetBeans.
     */
    private void initComponents () {//GEN-BEGIN:initComponents
        getContentPane ().setLayout (new java.awt.BorderLayout ());

        jScrollPane = new javax.swing.JScrollPane ();

        getContentPane ().add (jScrollPane, "Center");

        jPanel = new javax.swing.JPanel ();
        jPanel.setLayout (new java.awt.BorderLayout ());

            jlblStatus = new javax.swing.JLabel ();
            jlblStatus.setToolTipText ("Status");
            jlblStatus.setBorder (new javax.swing.border.CompoundBorder (
                new javax.swing.border.CompoundBorder (
                new javax.swing.border.EmptyBorder (new java.awt.Insets(1, 1, 1, 1)),
                new javax.swing.border.LineBorder (java.awt.Color.gray)),
                new javax.swing.border.EmptyBorder (new java.awt.Insets(0, 2, 0, 0))));
            jlblStatus.setText ("Idle");
            jPanel.add (jlblStatus, "Center");

            blip = new Blip ();
            blip.setToolTipText ("Activity Indicator");
            blip.setPreferredSize (new java.awt.Dimension(23, 23));
            blip.setOpaque (true);
            blip.setBorder (new javax.swing.border.CompoundBorder (
                new javax.swing.border.CompoundBorder (
                new javax.swing.border.EmptyBorder (new java.awt.Insets(1, 1, 1, 1)),
                new javax.swing.border.LineBorder (java.awt.Color.gray)),
                new javax.swing.border.EmptyBorder (new java.awt.Insets(1, 1, 1, 1))));
            blip.setForeground (new java.awt.Color (153, 153, 204));

            jPanel.add (blip, "East");

        getContentPane ().add (jPanel, "South");

    }//GEN-END:initComponents


    /**
     * Updates status line and starts blip when a task is started. 
     */
    private void remoteTableTaskStarted (RemoteTableTaskEvent evt) {//GEN-FIRST:event_remoteTableTaskStarted

        switch (evt.getType()) {
          case evt.CONNECT:
            jlblStatus.setText("Connecting...");
            break;
          case evt.DISCONNECT:
            jlblStatus.setText("Disconnecting...");
            break;
          case evt.UPDATE:
            jlblStatus.setText("Updating server...");
            break;
        }

        if (activeTasks++ == 0) {
            blip.start();
        }

    }//GEN-LAST:event_remoteTableTaskStarted


    /**
     * Updates status line and stops blip when a task ends. 
     */
    private void remoteTableTaskEnded (RemoteTableTaskEvent evt) {//GEN-FIRST:event_remoteTableTaskEnded

        if (--activeTasks == 0) {
            blip.stop();
        }

        FutureResult res = evt.getFutureResult();
        InvocationTargetException ex = res.getException();
        switch (evt.getType()) {
          case evt.CONNECT:
            if (ex == null) {
                jlblStatus.setText("Connected");
            } else {
                jlblStatus.setText("Connect failed");
                ex.getTargetException().printStackTrace();
            }
            break;
          case evt.DISCONNECT:
            if (ex == null) {
                jlblStatus.setText("Disconnected");
            } else {
                jlblStatus.setText("Disconnect failed");
                ex.getTargetException().printStackTrace();
            }
            break;
          case evt.UPDATE:
            if (ex == null) {
                jlblStatus.setText("Update complete");
            } else {
                jlblStatus.setText("Update failed");
                ex.getTargetException().printStackTrace();
            }
            break;
        }

    }//GEN-LAST:event_remoteTableTaskEnded


    /**
     * Updates status line when local table changes. 
     */
    private void localTableChanged(TableModelEvent evt) {
        switch (evt.getType()) {
          case evt.DELETE:
            jlblStatus.setText("Rows removed");
            break;
          case evt.INSERT:
            jlblStatus.setText("Rows inserted");
            break;
          case evt.UPDATE:
            int row = evt.getFirstRow();
            int lastRow = evt.getLastRow();
            int col = evt.getColumn();
            if (lastRow == row && col != evt.ALL_COLUMNS) {
                jlblStatus.setText("Cell ("+row+","+col+") updated");
            } else {
                jlblStatus.setText("Cells updated");
            }
            break;
        }
    }


    /**
     * Connect to the remote model. Called on system thread. 
     */
    public void start() {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                connect();
            }
        });
    }

    /**
     * Disconnect from remote model. Called on system thread. 
     */
    public void stop() {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                disconnect();
            }
        });
    }


    /**
     * Lookup the remote model and connect remoteTable to it. 
     */
    public FutureResult connect() {
        try {
            RemoteTableModel remoteModel = lookupRemoteModel();
            return remoteTable.connect(remoteModel);
        }
        catch (Exception ex) {
            jlblStatus.setText("Connect failed");
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * Disconnect remoteTable from the remote model. 
     */
    public FutureResult disconnect() {
        return remoteTable.disconnect();
    }

    /**
     * Called from main just before calling exit. Asks remoteTable
     * to disconnect and waits up to timeout msecs for it to complete.
     * This gives the disconnect task time to run before exit steps
     * on our threads. 
     */
    public void shutdown(int timeout) {
        FutureResult task = remoteTable.disconnect();
        if (task != null) {
            try {
                task.timedGet(timeout);
            }
            catch (Exception ex) { }
        }
    }


    /**
     * Creates local table model. Override to return a table model 
     * of your choice. 
     * <p>
     * Note: The remote model provides the row data, but the local
     * and remote models must agree on the column structure. 
     */
    protected DefaultTableModel createLocalModel() {
        return new DefaultModelTemplate();
    }

    /**
     * Locates the default remote table server. Override to 
     * return a remote table model of your choice. 
     */
    protected RemoteTableModel lookupRemoteModel()
        throws MalformedURLException, NotBoundException, RemoteException {
        return lookupRemoteModel("/RemoteTableServer");
    }

    /**
     * Lookup remote table model given its name.
     */
    protected RemoteTableModel lookupRemoteModel(String name)
        throws MalformedURLException, NotBoundException, RemoteException {

        jlblStatus.setText("Looking up \"" + name + "\".");
        return (RemoteTableModel) Naming.lookup(name);
    }


    /**
     * Launches this applet in a frame.
     */
    public static void main(String[] args) {

        /* Create and install a security manager. */
        if (System.getSecurityManager() == null) {
            System.setSecurityManager(new RMISecurityManager());
        }

        JFrame frame = new JFrame("Remote Table Editor");
        final RemoteTableEditor applet = new RemoteTableEditor();
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent event) {
                applet.shutdown(1000);
                System.exit(0);
            }
        });
        frame.getContentPane().add(applet, "Center");
        frame.pack();
        frame.show();
        applet.init();
        applet.start();
    }

}